<!DOCTYPE html><head><title>数据结构与算法复习小抄（持续更新） - yzsj98's blog</title><meta name="description" content="复习、整理一些知识点"><script src="/bundle.js" onload="[].flat||(location='/update.html')"></script></head><main><article><h1>数据结构与算法复习小抄（持续更新）</h1><blockquote><p>数据结构复习备忘！随着复习的进行而持续更新，配套代码仓库：[todo]</p></blockquote><h2 id="changelog">Changelog</h2><ul><li>2022年2月25日 添加排序[选择、插入、归并和快速]，查找[二分查找各种变种和模板]。</li></ul><h2 id="一、排序">一、排序</h2><h3 id="11-排序工具">1.1 排序工具</h3><p>后续具体排序算法实现类的父类，主要目的是引入排序检测函数：构造一个随机大数组，以粗略验证所写排序算法是否正确：</p><pre><code class="language-java">abstract public class SortAlgoBase {
    public SortAlgoBase() {
        check(); // 实例化后即检测输出
    }
    // ... 部分代码略
    abstract protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr);

    protected void check() {
        Integer[] test = randomArray(1000, 300);
        sort(test);
        if (isSorted(test) &amp;&amp; new HashSet&lt;Integer&gt;(Arrays.asList(test)).equals(new HashSet&lt;Integer&gt;(Arrays.asList(test)))) {
            System.out.print(getName() + &quot; 测试通过，用时：&quot;);
            // 测试用时
            Integer[] arr = randomArray(20000, 10000);
            long startTime = System.nanoTime();
            sort(arr);
            long endTime = System.nanoTime();
            double time = (endTime - startTime) / 1000000000.0;
            System.out.println(time + &quot;s&quot;);
        } else {
            System.out.println(getName() + &quot; 测试失败&quot;);
        }
    }
    // 常用的交换函数
    protected &lt;E&gt; void swap(E[] arr, int i, int j) {
        E t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}
</code></pre><h3 id="12-选择排序">1.2 选择排序</h3><p><strong>思路：</strong>遍历数组，从当前位置向后选择最小的元素交换到当前元素位置。</p><pre><code class="language-java">public class SelectionSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return &quot;选择排序&quot;;
    }

    @Override
    protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr) {
        for (int i = 0; i &lt; arr.length; ++i) {
            int minIdx = i;

            for (int j = i + 1; j &lt; arr.length; ++j) {
                if (arr[j].compareTo(arr[minIdx]) &lt; 0)
                    minIdx = j;
            }

            swap(arr, i, minIdx);
        }
    }

    public static void main(String[] args) {
        new SelectionSort().check();
        new SelectionSort().checkOrdered();
    }
}
</code></pre><h3 id="13-插入排序">1.3 插入排序</h3><p><strong>特点：</strong>对于有序数组，复杂度 O(N)，而选择排序复杂度稳定为 O(N^2)。</p><h4 id="131-第一版代码">1.3.1 第一版代码</h4><p><strong>思路：</strong> 遍历数组，将前位置元素依次交换移动到合适位置，插入元素。</p><pre><code class="language-java">public class InsertionSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return &quot;选择排序 ver1&quot;;
    }

    @Override
    protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr) {
        for (int i = 0; i &lt; arr.length; ++i) {
            // 把 arr[i] 插入到合适的位置
            for (int j = i; j - 1 &gt;= 0; j--) {
                if (arr[j - 1].compareTo(arr[j]) &gt; 0) {
                    swap(arr, j - 1, j);
                } else {
                    break;
                }
            }
        }
    }

    public static void main(String[] args) {
        new InsertionSort();
    }
}
</code></pre><h4 id="132-优化代码">1.3.2 优化代码</h4><p><strong>上一版代码存在的问题：</strong>有一定的内存优化的可能，即可以去掉 <code>swap</code>。</p><p><strong>思路：</strong> 遍历数组，挪动腾出当前元素合适的位置，放入。</p><pre><code class="language-java">public class InsertionSort2 extends SortAlgoBase {
    @Override
    protected String getName() {
        return &quot;选择排序 ver2&quot;;
    }

    @Override
    protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr) {
        for (int i = 0; i &lt; arr.length; ++i) {
            // 把 arr[i] 放入到合适的位置
            E p = arr[i];
            int j = i;
            for (; j - 1 &gt;= 0; j--) {
                if (p.compareTo(arr[j-1]) &lt; 0) {
                    arr[j] = arr[j - 1];
                } else {
                    break;
                }
            }
            arr[j] = p;
        }
    }

    public static void main(String[] args) {
        new InsertionSort2();
    }
}
</code></pre><h3 id="14-归并排序">1.4 归并排序</h3><h4 id="141-递归实现">1.4.1 递归实现</h4><p><strong>思路：</strong> 用分治法的思想，类似于二叉树后序遍历的顺序，依次排序左右半区间，然后O(N)时间 merge。</p><pre><code class="language-java">public class MergeSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return &quot;归并排序 递归版本&quot;;
    }

    @Override
    protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    private &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr, int l, int r) {
        if (l &gt;= r) return;
        int mid = l + (r - l) / 2;
        sort(arr, l, mid);
        sort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }

    private static &lt;E extends Comparable&lt;E&gt;&gt; void merge(E[] arr, int l, int mid, int r) {
        E[] aux = Arrays.copyOfRange(arr, l, r + 1);
        int i = 0;
        int j = mid - l + 1;
        int k = l;
        while (i &lt; mid - l + 1 &amp;&amp; j &lt; r + 1 - l) {
            if (aux[i].compareTo(aux[j]) &lt; 0) {
                arr[k++] = aux[i++];
            } else {
                arr[k++] = aux[j++];
            }
        }
        while (i &lt; mid - l + 1) {
            arr[k++] = aux[i++];
        }
        while (j &lt; r + 1 - l) {
            arr[k++] = aux[j++];
        }
    }

    public static void main(String[] args) {
        new MergeSort();
    }
}
</code></pre><h4 id="142-算法优化">1.4.2 算法优化</h4><p>优化点：</p><ol><li><p>使用插入排序优化归并排序（n=5,000,000差不多能提升0.3秒）。</p></li><li><p><code>merge</code> ，如果 <code>arr[mid]&lt;arr[mid+1]</code>则不需要归并。这样对于有序数组，复杂度降为 O(n)。</p></li><li><p>内存上的优化：可以（只开创一次空间temp），然后merge开始时arraycopy一下：</p><pre><code class="language-java">System.arraycopy(arr, l, temp, l, r-l+1);
</code></pre></li></ol><pre><code class="language-java">public class MergeSort2 extends SortAlgoBase {
    @Override
    protected String getName() {
        return &quot;归并排序 递归版本2&quot;;
    }

    @Override
    protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    private &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr, int l, int r) {
        if (l &gt;= r) return;
        // 优化点1：
//        if (r - l &lt;= 15) {
//            // 使用插入排序
//            return; // 别忘了 return
//        }
        int mid = l + (r - l) / 2;
        sort(arr, l, mid);
        sort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }

    private static &lt;E extends Comparable&lt;E&gt;&gt; void merge(E[] arr, int l, int mid, int r) {
        // mid最大也是 (N + N-1) / 2 = N，故 mid + 1 不会越界
        if (arr[mid].compareTo(arr[mid + 1]) &lt;= 0) return; // 优化点2：
        E[] aux = Arrays.copyOfRange(arr, l, r + 1); // [l, r+1)
        int i = 0;
        int j = mid - l + 1;
        int k = l;
        while (i &lt; mid - l + 1 &amp;&amp; j &lt; r + 1 - l) {
            if (aux[i].compareTo(aux[j]) &lt; 0) {
                arr[k++] = aux[i++];
            } else {
                arr[k++] = aux[j++];
            }
        }
        while (i &lt; mid - l + 1) {
            arr[k++] = aux[i++];
        }
        while (j &lt; r + 1 - l) {
            arr[k++] = aux[j++];
        }
    }

    public static void main(String[] args) {
        new MergeSort2();
    }
}
</code></pre><h4 id="143-迭代实现">1.4.3 迭代实现</h4><p>即：自底向上归并</p><pre><code class="language-java">public class MergeSort3 extends SortAlgoBase {
    @Override
    protected String getName() {
        return &quot;归并排序 迭代版本&quot;;
    }

    @Override
    protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr) {
        E[] aux = Arrays.copyOf(arr, arr.length);
        final int n = arr.length;

        for (int sz = 1; sz &lt; n; sz += sz) { // sz 每次翻倍
            for (int i = 0; i + sz &lt; n; i += sz + sz) { // i + sz - 1 是中点（左）
                // arr[i, i+sz-1], arr[i+sz, i+2sz-1]
                if (arr[i + sz - 1].compareTo(arr[i + sz]) &gt; 0) { // 之前的优化点
                    merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, n - 1), aux);
                }
            }
        }
    }


    private static &lt;E extends Comparable&lt;E&gt;&gt; void merge(E[] arr, int l, int mid, int r, E[] aux) {
        for (int i = l; i &lt;= r; ++i) {
            aux[i] = arr[i];
        }
        int i = l;
        int j = mid + 1;
        int k = l;
        while (i &lt; mid + 1 &amp;&amp; j &lt; r + 1) {
            if (aux[i].compareTo(aux[j]) &lt; 0) {
                arr[k++] = aux[i++];
            } else {
                arr[k++] = aux[j++];
            }
        }
        while (i &lt; mid + 1) {
            arr[k++] = aux[i++];
        }
        while (j &lt; r + 1) {
            arr[k++] = aux[j++];
        }
    }

    public static void main(String[] args) {
        new MergeSort3();
    }
}
</code></pre><h3 id="15-快速排序">1.5 快速排序</h3><p><strong>思路：</strong>用分治法的思想，类似于二叉树前序遍历的顺序，先O(N)时间的partition确定一个pivot的位置，然后排序 pivot 左右区间。</p><p>快速排序 partition 的灵魂在于把握<strong>循环不变量</strong>。</p><h4 id="151-第一版：单路非随机算法">1.5.1 第一版：单路非随机算法</h4><pre><code class="language-java">public class QickSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return &quot;快速排序 版本一&quot;;
    }

    @Override
    protected &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    private &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr, int l, int r) {
        if (l &gt;= r) return;
        int p = partition(arr, l, r);
        sort(arr, l, p - 1);
        sort(arr, p + 1, r);
    }

    private &lt;E extends Comparable&lt;E&gt;&gt; int partition(E[] arr, int l, int r) {
        final E v = arr[l];
        // 循环不变量 arr[l+1, j] &lt; v, [j+1, i) &gt;= v
        int j = l;
        for (int i = l + 1; i &lt;= r; ++i) {
            if (arr[i].compareTo(v) &lt; 0) { // i 指向的 &lt; v
                j++; // j 跨越分界点，
                swap(arr, i, j); // 与 i 交换
            }
            // else: &gt;= v, i++ 即可，略
        }
        // 循环结束：arr[l+1, j] &lt; v, [j+1, r] &gt;= v，交换 l 和 j 即可。
        swap(arr, l, j);
        return j;
    }
    public static void main(String[] args) {
        new QickSort();
    }
}
</code></pre><h4 id="152-第二版：引入随机化，随机算法">1.5.2 第二版：引入随机化，随机算法</h4><p><strong>上一版本存在的问题</strong>：完全有序的数组排序时间复杂度是 O(n^2)</p><p><strong>解决：</strong>引入随机化，即每次随机选取一个位置的值为 pivot，避免分治“链表化”。</p><p>简单引入随机即可。</p><pre><code class="language-java">private static Random rnd = new Random();

private &lt;E extends Comparable&lt;E&gt;&gt; int partition(E[] arr, int l, int r) {
    int rand = rnd.nextInt(r - l + 1) + l;
    swap(arr, l, rand);
    // ...
</code></pre><h4 id="153-第三版：双路快速排序">1.5.3 第三版：双路快速排序</h4><p><strong>上一版本存在的问题</strong>：全等的数组排序时间复杂度是 O(n^2)</p><p><strong>解决：</strong>双路快速排序，使得全等的情况，pivot集中在中间</p><p>使用双指针，更改循环不变量即可：</p><pre><code class="language-java">private &lt;E extends Comparable&lt;E&gt;&gt; int partition(E[] arr, int l, int r) {
    int rand = rnd.nextInt(r - l + 1) + l;
    swap(arr, l, rand);
    final E v = arr[l];
    // 循环不变量：arr[l+1, i) &lt;= 0, arr(j, r] &gt;= 0
    int i = l + 1, j = r;
    for (; ; ) {
        while (i &lt;= j &amp;&amp; arr[i].compareTo(v) &lt; 0) i++;
        while (i &lt;= j &amp;&amp; arr[j].compareTo(v) &gt; 0) j--;
        if (i &gt;= j) break; // i = j，说明 arr[i] = v;
        swap(arr, i, j);
        i++;
        j--;
    }
    // 如果i,j不等，一定是 i 超过了 j，且 [j]&lt;v, [i] &gt;= v 所以要和 j 交换。
    swap(arr, l, j);
    return j;
}
</code></pre><h4 id="154-第四版：三路快速排序">1.5.4 第四版：三路快速排序</h4><p><strong>上一版本存在的问题</strong>：全等的数组时，相等的区间可以不用处理。即相等的区间可以在下次分区的时候排除。</p><p><strong>解决：</strong>三路快速排序，区间划分成三部分。</p><p>使用三指针，更改循环不变量即可：</p><pre><code class="language-java">private &lt;E extends Comparable&lt;E&gt;&gt; void sort(E[] arr, int l, int r) {
    if (l &gt;= r) return;
    int p = rnd.nextInt(r - l + 1) + l;
    swap(arr, l, p);

    // 循环不变量 arr[l+1, lt] &lt; v, arr[lt+1, i) = v, arr[gt, r] &gt; v
    final E v = arr[l];
    int lt = l, i = l + 1, gt = r + 1;
    while (i &lt; gt) {
        E cur = arr[i];
        if (cur.compareTo(v) &lt; 0) {
            lt++;
            swap(arr, i, lt);
            i++;
        } else if (cur.compareTo(v) &gt; 0) {
            gt--;
            swap(arr, i, gt);
            // i 此时指向未处理元素，不用++
        } else {
            i++;
        }
    }
    swap(arr, l, lt);
    // 此时： arr[l+1, lt-1] &lt; v, arr[lt, gt-1] = v, arr[gt, r] &gt; v
    sort(arr, l, lt - 1);
    sort(arr, gt, r);
}
</code></pre><h2 id="二、二分查找">二、二分查找</h2><h3 id="21-常规">2.1 常规</h3><p><strong>递归写法：</strong></p><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int search(E[] data, E target) {
    return search(data, target, 0, data.length - 1);
}

// [l, r]
public static &lt;E extends Comparable&lt;E&gt;&gt; int search(E[] data, E target, int l, int r) {
    if (l &gt; r) return -1;
    int mid = l + (r - l) / 2;
    if (data[mid].compareTo(target) == 0)
        return mid;
    if (data[mid].compareTo(target) &lt; 0)
        return search(data, target, mid + 1, r);
    return search(data, target, l, mid - 1);
}
</code></pre><p><strong>迭代写法：</strong></p><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int search(E[] data, E target) {

    int l = 0, r = data.length - 1; 

    while (l &lt;= r) { // 搜索范围：[l, r]
        int mid = l + (r - l) / 2;
        if(data[mid].compareTo(target) == 0)
            return mid;
        if(data[mid].compareTo(target) &lt; 0)
            l = mid + 1;
        else
            r = mid - 1;
    }
    return -1;
}

public static &lt;E extends Comparable&lt;E&gt;&gt; int search(E[] data, E target) {

    int lo = 0, hi = data.length; // 搜索空间

    while (lo &lt;= hi) { // 搜索范围：[l, r]
        int mid = lo + (hi - lo) / 2;
        if(data[mid].compareTo(target) == 0)
            return mid;
        if(data[mid].compareTo(target) &lt; 0)
            lo = mid + 1;
        else
            hi = mid;
    }
    return -1;
}
</code></pre><h3 id="22-ceil-上界">2.2 Ceil 上界</h3><h4 id="221-ceil">2.2.1 ceil</h4><p><strong>即：</strong>大于 target 的最小值，如大于60分的最小值。</p><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int upper(E[] data, E target) {

    int l = 0, r = data.length; // 搜索空间：[0, n]，需要＋1

    // data[l, r]
    while (l &lt; r) { // 小于号原因：一定有解，且 l=r 时得到解
        int mid = l + (r - l) / 2;
        if(data[mid].compareTo(target) &lt;= 0) // [l, mid] 一定不满足，可以排除
            l = mid + 1;
        else
            r = mid; // 不能排除 mid，因为 mid 可能是解，进一步求最小
    }
    return l;
}
</code></pre><h4 id="222-upper_ceil">2.2.2 upper_ceil</h4><p><strong>Ceil:</strong> 天花板，向上取整</p><p><strong>即：</strong></p><ol><li>如果数组中存在元素，返回最大索引；</li><li>数组中不存在元素，返回 ceil。</li></ol><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int upperCeil(E[] data, E target) {
    int upper = upper(data, target);
    if (upper-1 &gt;= 0 &amp;&amp; data[upper - 1].compareTo(target) == 0) {
        return upper - 1;
    }
    return upper;
}
</code></pre><h4 id="223-lower_ceil">2.2.3 lower_ceil</h4><p><strong>即：</strong></p><ol><li>如果数组中存在元素，返回最小索引；</li><li>数组中不存在元素，返回 ceil。</li></ol><p><code>&gt;=</code> target 的最小索引</p><p>修改 upper 函数，改变（1）处的符号即可：</p><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int lowerCeil(E[] data, E target) {

    int l = 0, r = data.length; // 搜索空间：[0, n]，需要＋1

    // data[l, r]
    while (l &lt; r) { // 小于号原因：一定有解，且 l=r 时得到解
        int mid = l + (r - l) / 2;
        if(data[mid].compareTo(target) &lt; 0) // (1) [l, mid] 一定不满足，可以排除
            l = mid + 1;
        else
            r = mid; // 不能排除 mid，因为 mid 可能是解，进一步求最小
    }
    return l;
}
</code></pre><h3 id="23-floor-下界">2.3 Floor 下界</h3><h4 id="231-floor">2.3.1 floor</h4><p><strong>即：</strong>小于 target 的最大值，如没及格的最高分。</p><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int floor(E[] data, E target) {

    int l = -1, r = data.length - 1; // 搜索空间：[-1, n-1]

    // data[l, r]
    while (l &lt; r) { // 一定有解，且 l=r 时得到解
        int mid = l + (r - l + 1) / 2; // 注意：+0.5 避免**相邻**的时候出现死循环
        if (data[mid].compareTo(target) &lt; 0)
            l = mid; // 不能排除 mid，因为 mid 可能是解
        else
            r = mid - 1;
    }
    return l;
}
</code></pre><h4 id="232-lower_floor">2.3.2 lower_floor</h4><p><strong>即：</strong></p><ol><li>如果数组中存在元素，返回最小索引；</li><li>数组中不存在元素，返回 floor。</li></ol><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int lowerFloor(E[] data, E target) {
    int floor = floor(data, target);
    if (floor+1 &lt; data.length &amp;&amp; data[floor+1].compareTo(target) == 0) {
        return floor+1;
    }
    return floor;
}
</code></pre><h4 id="233-upper_floor">2.3.3 upper_floor</h4><p><strong>即：</strong>小于等于 target 的最大值</p><pre><code class="language-java">public static &lt;E extends Comparable&lt;E&gt;&gt; int upperFloor(E[] data, E target) {

    int l = -1, r = data.length - 1; // 搜索空间：[-1, n-1]

    // data[l, r]
    while (l &lt; r) { // 一定有解，且 l=r 时得到解
        int mid = l + (r - l + 1) / 2; // 注意：+0.5 避免**相邻**的时候出现死循环
        if (data[mid].compareTo(target) &lt;= 0)
            l = mid; // 不能排除 mid，因为 mid 可能是解
        else
            r = mid - 1;
    }
    return l;
}
</code></pre><h2 id="附、java-算法常用工具函数">附、Java 算法常用工具函数</h2><h3 id="a1-数组类">A.1 数组类</h3><h3 id="a2-集合类">A.2 集合类</h3><h3 id="a3-其他">A.3 其他</h3></article></main>