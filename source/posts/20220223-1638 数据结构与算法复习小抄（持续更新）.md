```

title: 数据结构与算法复习小抄（持续更新）

date: 2022.02.23 16:38

tags: Java 算法 数据结构

description: 复习、整理一些知识点

```
> 数据结构复习备忘！随着复习的进行而持续更新，配套代码仓库：[AlgoStudy](https://github.com/yzsj98/AlgoStudy)

## Changelog

- 2022年2月25日 添加排序[选择、插入、归并和快速]，查找[二分查找各种变种和模板]。
- 2022年3月6日 添加堆排序。

## 一、排序

### 1.1 排序工具

后续具体排序算法实现类的父类，主要目的是引入排序检测函数：构造一个随机大数组，以粗略验证所写排序算法是否正确：

```java
abstract public class SortAlgoBase {
    public SortAlgoBase() {
        check(); // 实例化后即检测输出
    }
	// ... 部分代码略
    abstract protected <E extends Comparable<E>> void sort(E[] arr);

    protected void check() {
        Integer[] test = randomArray(1000, 300);
        sort(test);
        if (isSorted(test) && new HashSet<Integer>(Arrays.asList(test)).equals(new HashSet<Integer>(Arrays.asList(test)))) {
            System.out.print(getName() + " 测试通过，用时：");
            // 测试用时
            Integer[] arr = randomArray(20000, 10000);
            long startTime = System.nanoTime();
            sort(arr);
            long endTime = System.nanoTime();
            double time = (endTime - startTime) / 1000000000.0;
            System.out.println(time + "s");
        } else {
            System.out.println(getName() + " 测试失败");
        }
    }
	// 常用的交换函数
    protected <E> void swap(E[] arr, int i, int j) {
        E t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}
```

### 1.2 选择排序

**思路：**遍历数组，从当前位置向后选择最小的元素交换到当前元素位置。

```java
public class SelectionSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return "选择排序";
    }

    @Override
    public <E extends Comparable<E>> void sort(E[] arr) {
        for (int i = 0; i < arr.length; ++i) {
            int minIdx = i;

            for (int j = i + 1; j < arr.length; ++j) {
                if (arr[j].compareTo(arr[minIdx]) < 0)
                    minIdx = j;
            }

            swap(arr, i, minIdx);
        }
    }

    public static void main(String[] args) {
        new SelectionSort().check();
        new SelectionSort().checkOrdered();
    }
}
```

### 1.3 插入排序

**特点：**对于有序数组，复杂度 O(N)，而选择排序复杂度稳定为 O(N^2)。

#### 1.3.1 第一版代码

**思路：** 遍历数组，将前位置元素依次交换移动到合适位置，插入元素。

```java
public class InsertionSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return "选择排序 ver1";
    }

    @Override
    public <E extends Comparable<E>> void sort(E[] arr) {
        for (int i = 0; i < arr.length; ++i) {
            // 把 arr[i] 插入到合适的位置
            for (int j = i; j - 1 >= 0; j--) {
                if (arr[j - 1].compareTo(arr[j]) > 0) {
                    swap(arr, j - 1, j);
                } else {
                    break;
                }
            }
        }
    }

    public static void main(String[] args) {
        new InsertionSort();
    }
}
```

#### 1.3.2 优化代码

**上一版代码存在的问题：**有一定的内存优化的可能，即可以去掉 `swap`。

**思路：** 遍历数组，挪动腾出当前元素合适的位置，放入。

```java
public class InsertionSort2 extends SortAlgoBase {
    @Override
    protected String getName() {
        return "选择排序 ver2";
    }

    @Override
    public <E extends Comparable<E>> void sort(E[] arr) {
        for (int i = 0; i < arr.length; ++i) {
            // 把 arr[i] 放入到合适的位置
            E p = arr[i];
            int j = i;
            for (; j - 1 >= 0; j--) {
                if (p.compareTo(arr[j-1]) < 0) {
                    arr[j] = arr[j - 1];
                } else {
                    break;
                }
            }
            arr[j] = p;
        }
    }

    public static void main(String[] args) {
        new InsertionSort2();
    }
}
```

### 1.4 归并排序

#### 1.4.1 递归实现

**思路：** 用分治法的思想，类似于二叉树后序遍历的顺序，依次排序左右半区间，然后O(N)时间 merge。

```java
public class MergeSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return "归并排序 递归版本";
    }

    @Override
    public <E extends Comparable<E>> void sort(E[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    private <E extends Comparable<E>> void sort(E[] arr, int l, int r) {
        if (l >= r) return;
        int mid = l + (r - l) / 2;
        sort(arr, l, mid);
        sort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }

    private static <E extends Comparable<E>> void merge(E[] arr, int l, int mid, int r) {
        E[] aux = Arrays.copyOfRange(arr, l, r + 1);
        int i = 0;
        int j = mid - l + 1;
        int k = l;
        while (i < mid - l + 1 && j < r + 1 - l) {
            if (aux[i].compareTo(aux[j]) < 0) {
                arr[k++] = aux[i++];
            } else {
                arr[k++] = aux[j++];
            }
        }
        while (i < mid - l + 1) {
            arr[k++] = aux[i++];
        }
        while (j < r + 1 - l) {
            arr[k++] = aux[j++];
        }
    }

    public static void main(String[] args) {
        new MergeSort();
    }
}
```

#### 1.4.2 算法优化

优化点：

1. 使用插入排序优化归并排序（n=5,000,000差不多能提升0.3秒）。

2. `merge` ，如果 `arr[mid]<arr[mid+1]`则不需要归并。这样对于有序数组，复杂度降为 O(n)。

3. 内存上的优化：可以（只开创一次空间temp），然后merge开始时arraycopy一下：

   ```java
   System.arraycopy(arr, l, temp, l, r-l+1);
   ```

```java
public class MergeSort2 extends SortAlgoBase {
    @Override
    protected String getName() {
        return "归并排序 递归版本2";
    }

    @Override
    public <E extends Comparable<E>> void sort(E[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    private <E extends Comparable<E>> void sort(E[] arr, int l, int r) {
        if (l >= r) return;
        // 优化点1：
//        if (r - l <= 15) {
//            // 使用插入排序
//            return; // 别忘了 return
//        }
        int mid = l + (r - l) / 2;
        sort(arr, l, mid);
        sort(arr, mid + 1, r);
        merge(arr, l, mid, r);
    }

    private static <E extends Comparable<E>> void merge(E[] arr, int l, int mid, int r) {
        // mid最大也是 (N + N-1) / 2 = N，故 mid + 1 不会越界
        if (arr[mid].compareTo(arr[mid + 1]) <= 0) return; // 优化点2：
        E[] aux = Arrays.copyOfRange(arr, l, r + 1); // [l, r+1)
        int i = 0;
        int j = mid - l + 1;
        int k = l;
        while (i < mid - l + 1 && j < r + 1 - l) {
            if (aux[i].compareTo(aux[j]) < 0) {
                arr[k++] = aux[i++];
            } else {
                arr[k++] = aux[j++];
            }
        }
        while (i < mid - l + 1) {
            arr[k++] = aux[i++];
        }
        while (j < r + 1 - l) {
            arr[k++] = aux[j++];
        }
    }

    public static void main(String[] args) {
        new MergeSort2();
    }
}
```

#### 1.4.3 迭代实现

即：自底向上归并

```java
public class MergeSort3 extends SortAlgoBase {
    @Override
    protected String getName() {
        return "归并排序 迭代版本";
    }

    @Override
    public <E extends Comparable<E>> void sort(E[] arr) {
        E[] aux = Arrays.copyOf(arr, arr.length);
        final int n = arr.length;

        for (int sz = 1; sz < n; sz += sz) { // sz 每次翻倍
            for (int i = 0; i + sz < n; i += sz + sz) { // i + sz - 1 是中点（左）
                // arr[i, i+sz-1], arr[i+sz, i+2sz-1]
                if (arr[i + sz - 1].compareTo(arr[i + sz]) > 0) { // 之前的优化点
                    merge(arr, i, i + sz - 1, Math.min(i + sz + sz - 1, n - 1), aux);
                }
            }
        }
    }


    private static <E extends Comparable<E>> void merge(E[] arr, int l, int mid, int r, E[] aux) {
        for (int i = l; i <= r; ++i) {
            aux[i] = arr[i];
        }
        int i = l;
        int j = mid + 1;
        int k = l;
        while (i < mid + 1 && j < r + 1) {
            if (aux[i].compareTo(aux[j]) < 0) {
                arr[k++] = aux[i++];
            } else {
                arr[k++] = aux[j++];
            }
        }
        while (i < mid + 1) {
            arr[k++] = aux[i++];
        }
        while (j < r + 1) {
            arr[k++] = aux[j++];
        }
    }

    public static void main(String[] args) {
        new MergeSort3();
    }
}
```

### 1.5 快速排序

**思路：**用分治法的思想，类似于二叉树前序遍历的顺序，先O(N)时间的partition确定一个pivot的位置，然后排序 pivot 左右区间。

快速排序 partition 的灵魂在于把握**循环不变量**。

#### 1.5.1 第一版：单路非随机算法

```java
public class QickSort extends SortAlgoBase {
    @Override
    protected String getName() {
        return "快速排序 版本一";
    }

    @Override
    public <E extends Comparable<E>> void sort(E[] arr) {
        sort(arr, 0, arr.length - 1);
    }

    private <E extends Comparable<E>> void sort(E[] arr, int l, int r) {
        if (l >= r) return;
        int p = partition(arr, l, r);
        sort(arr, l, p - 1);
        sort(arr, p + 1, r);
    }

    private <E extends Comparable<E>> int partition(E[] arr, int l, int r) {
        final E v = arr[l];
		// 循环不变量 arr[l+1, j] < v, [j+1, i) >= v
        int j = l;
        for (int i = l + 1; i <= r; ++i) {
            if (arr[i].compareTo(v) < 0) { // i 指向的 < v
                j++; // j 跨越分界点，
                swap(arr, i, j); // 与 i 交换
            }
            // else: >= v, i++ 即可，略
        }
        // 循环结束：arr[l+1, j] < v, [j+1, r] >= v，交换 l 和 j 即可。
        swap(arr, l, j);
        return j;
    }
    public static void main(String[] args) {
        new QickSort();
    }
}
```

#### 1.5.2 第二版：引入随机化，随机算法

**上一版本存在的问题**：完全有序的数组排序时间复杂度是 O(n^2)

**解决：**引入随机化，即每次随机选取一个位置的值为 pivot，避免分治“链表化”。

简单引入随机即可。

```java
private static Random rnd = new Random();

private <E extends Comparable<E>> int partition(E[] arr, int l, int r) {
    int rand = rnd.nextInt(r - l + 1) + l;
    swap(arr, l, rand);
    // ...
```

#### 1.5.3 第三版：双路快速排序

**上一版本存在的问题**：全等的数组排序时间复杂度是 O(n^2)

**解决：**双路快速排序，使得全等的情况，pivot集中在中间

使用双指针，更改循环不变量即可：

```java
private <E extends Comparable<E>> int partition(E[] arr, int l, int r) {
    int rand = rnd.nextInt(r - l + 1) + l;
    swap(arr, l, rand);
    final E v = arr[l];
    // 循环不变量：arr[l+1, i) <= 0, arr(j, r] >= 0
    int i = l + 1, j = r;
    for (; ; ) {
        while (i <= j && arr[i].compareTo(v) < 0) i++;
        while (i <= j && arr[j].compareTo(v) > 0) j--;
        if (i >= j) break; // i = j，说明 arr[i] = v;
        swap(arr, i, j);
        i++;
        j--;
    }
    // 如果i,j不等，一定是 i 超过了 j，且 [j]<v, [i] >= v 所以要和 j 交换。
    swap(arr, l, j);
    return j;
}
```

#### 1.5.4 第四版：三路快速排序

**上一版本存在的问题**：全等的数组时，相等的区间可以不用处理。即相等的区间可以在下次分区的时候排除。

**解决：**三路快速排序，区间划分成三部分。

使用三指针，更改循环不变量即可：

```java
private <E extends Comparable<E>> void sort(E[] arr, int l, int r) {
    if (l >= r) return;
    int p = rnd.nextInt(r - l + 1) + l;
    swap(arr, l, p);

    // 循环不变量 arr[l+1, lt] < v, arr[lt+1, i) = v, arr[gt, r] > v
    final E v = arr[l];
    int lt = l, i = l + 1, gt = r + 1;
    while (i < gt) {
        E cur = arr[i];
        if (cur.compareTo(v) < 0) {
            lt++;
            swap(arr, i, lt);
            i++;
        } else if (cur.compareTo(v) > 0) {
            gt--;
            swap(arr, i, gt);
            // i 此时指向未处理元素，不用++
        } else {
            i++;
        }
    }
    swap(arr, l, lt);
    // 此时： arr[l+1, lt-1] < v, arr[lt, gt-1] = v, arr[gt, r] > v
    sort(arr, l, lt - 1);
    sort(arr, gt, r);
}
```

### 1.5 堆排序

**思路：**就地建立最大二叉堆，然后从尾部依次添加最大值，每次拿到最大值后调整维持堆结构。

```java
@Override
public <E extends Comparable<E>> void sort(E[] arr) {
    final int n = arr.length;

    // 就地建立二叉堆：升序排序->最大堆，降序排序->最小堆
    // k 初始为最后一个叶子节点的父节点
    for (int k = (n - 1 - 1) / 2; k >= 0; k--) {
        sink(arr, k, n);
    }


    // 排序
    int k = n - 1;
    while (k > 0) {
        swap(arr, 0, k--);
        sink(arr, 0, k);
    }
}

private void sink(Comparable[] pq, int k, int n) {
    while (2 * k + 1 < n) { // 左节点未越界
        int j = 2 * k + 1;
        if (j + 1 < n && pq[j].compareTo(pq[j + 1]) < 0) j++;
        if (pq[j].compareTo(pq[k]) <= 0) break;
        swap(pq, k, j);
        k = j;
    }
}
```

## 二、二分查找

### 2.1 常规

**递归写法：**

```java
public static <E extends Comparable<E>> int search(E[] data, E target) {
    return search(data, target, 0, data.length - 1);
}

// [l, r]
public static <E extends Comparable<E>> int search(E[] data, E target, int l, int r) {
    if (l > r) return -1;
    int mid = l + (r - l) / 2;
    if (data[mid].compareTo(target) == 0)
        return mid;
    if (data[mid].compareTo(target) < 0)
        return search(data, target, mid + 1, r);
    return search(data, target, l, mid - 1);
}
```

**迭代写法：**

```java
public static <E extends Comparable<E>> int search(E[] data, E target) {

    int l = 0, r = data.length - 1; 

    while (l <= r) { // 搜索范围：[l, r]
        int mid = l + (r - l) / 2;
        if(data[mid].compareTo(target) == 0)
            return mid;
        if(data[mid].compareTo(target) < 0)
            l = mid + 1;
        else
            r = mid - 1;
    }
    return -1;
}

public static <E extends Comparable<E>> int search(E[] data, E target) {

    int lo = 0, hi = data.length; // 搜索空间

    while (lo <= hi) { // 搜索范围：[l, r]
        int mid = lo + (hi - lo) / 2;
        if(data[mid].compareTo(target) == 0)
            return mid;
        if(data[mid].compareTo(target) < 0)
            lo = mid + 1;
        else
            hi = mid;
    }
    return -1;
}
```

### 2.2 Ceil 上界

#### 2.2.1 ceil

**即：**大于 target 的最小值，如大于60分的最小值。

```java
public static <E extends Comparable<E>> int upper(E[] data, E target) {

    int l = 0, r = data.length; // 搜索空间：[0, n]，需要＋1

    // data[l, r]
    while (l < r) { // 小于号原因：一定有解，且 l=r 时得到解
        int mid = l + (r - l) / 2;
        if(data[mid].compareTo(target) <= 0) // [l, mid] 一定不满足，可以排除
            l = mid + 1;
        else
            r = mid; // 不能排除 mid，因为 mid 可能是解，进一步求最小
    }
    return l;
}
```

#### 2.2.2 upper_ceil 

**Ceil:** 天花板，向上取整

**即：**

1. 如果数组中存在元素，返回最大索引；
2. 数组中不存在元素，返回 ceil。

```java
public static <E extends Comparable<E>> int upperCeil(E[] data, E target) {
    int upper = upper(data, target);
    if (upper-1 >= 0 && data[upper - 1].compareTo(target) == 0) {
        return upper - 1;
    }
    return upper;
}
```

#### 2.2.3 lower_ceil

**即：**

1. 如果数组中存在元素，返回最小索引；
2. 数组中不存在元素，返回 ceil。

`>=` target 的最小索引

修改 upper 函数，改变（1）处的符号即可：

```java
public static <E extends Comparable<E>> int lowerCeil(E[] data, E target) {

    int l = 0, r = data.length; // 搜索空间：[0, n]，需要＋1

    // data[l, r]
    while (l < r) { // 小于号原因：一定有解，且 l=r 时得到解
        int mid = l + (r - l) / 2;
        if(data[mid].compareTo(target) < 0) // (1) [l, mid] 一定不满足，可以排除
            l = mid + 1;
        else
            r = mid; // 不能排除 mid，因为 mid 可能是解，进一步求最小
    }
    return l;
}
```

### 2.3 Floor 下界

#### 2.3.1 floor

**即：**小于 target 的最大值，如没及格的最高分。

```java
public static <E extends Comparable<E>> int floor(E[] data, E target) {

    int l = -1, r = data.length - 1; // 搜索空间：[-1, n-1]

    // data[l, r]
    while (l < r) { // 一定有解，且 l=r 时得到解
        int mid = l + (r - l + 1) / 2; // 注意：+0.5 避免**相邻**的时候出现死循环
        if (data[mid].compareTo(target) < 0)
            l = mid; // 不能排除 mid，因为 mid 可能是解
        else
            r = mid - 1;
    }
    return l;
}
```

#### 2.3.2 lower_floor

**即：**

1. 如果数组中存在元素，返回最小索引；
2. 数组中不存在元素，返回 floor。

```java
public static <E extends Comparable<E>> int lowerFloor(E[] data, E target) {
    int floor = floor(data, target);
    if (floor+1 < data.length && data[floor+1].compareTo(target) == 0) {
        return floor+1;
    }
    return floor;
}
```

#### 2.3.3 upper_floor

**即：**小于等于 target 的最大值

```java
public static <E extends Comparable<E>> int upperFloor(E[] data, E target) {

    int l = -1, r = data.length - 1; // 搜索空间：[-1, n-1]

    // data[l, r]
    while (l < r) { // 一定有解，且 l=r 时得到解
        int mid = l + (r - l + 1) / 2; // 注意：+0.5 避免**相邻**的时候出现死循环
        if (data[mid].compareTo(target) <= 0)
            l = mid; // 不能排除 mid，因为 mid 可能是解
        else
            r = mid - 1;
    }
    return l;
}
```

## 附、Java 算法常用工具函数

### A.1 数组类

### A.2 集合类

### A.3 其他